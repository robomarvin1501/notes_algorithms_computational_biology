\documentclass{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{blindtext}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{booktabs}
\usepackage{float}
\usepackage[bookmarks=true]{hyperref}
\usepackage{bookmark}
\usepackage{bbm}
\usepackage{wrapfig}
\usepackage[autostyle=true]{csquotes}
\graphicspath{ {./images/} }
\usepackage[bottom=0.5cm, right=1.5cm, left=1.5cm, top=1.5cm]{geometry}

\newtheorem{theorem}{Theorem}
\newtheorem{exercise}{Exercise}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}[section]

\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\p}{\ensuremath{\mathbb{P}}}
\newcommand{\E}{\ensuremath{\mathbb{E}}}
\newcommand{\F}{\ensuremath{\mathcal{F}}}
\newcommand{\1}{\ensuremath{\mathbbm{1}}}
\newcommand{\B}{\ensuremath{\mathbbm{B}}}

\title{Lecture 2 - Sequence alignment}
\author{Gidon Rosalki}
\date{2025-10-21}


\begin{document}
\maketitle
\noindent\textbf{Notice:} If you find any mistakes, please open an issue at \href{https://github.com/robomarvin1501/notes\_algorithms\_computational\_biology}{\texttt{https://github.com/robomarvin1501/notes\_algorithms\_computational\_biology}}

\section{Sequence alignment}%
\label{sec:Sequence alignment}
Let us suppose that we have three sequences: \begin{enumerate}
    \item CTAACTG... 
    \item GAGTG.... 
    \item GACTG...
\end{enumerate}
As we can see, sequences 2 and 3 appear to be very similar, they appear directly above each other, and only have one
letter of difference. What is less obvious, is the similarity between sequences 1 and 2. If we begin the second sequence
from the first A of the first sequence, then they are remarkably similar, with only the difference of 2 letters.
Additionally, we could just add 2 spaces between the first and second letters of the second sequence, and once again
have a great degree of similarity between them.

Let there be $s^*,t^* \in \left\{A, C, G, T, -\right\}^*$, such that $\left|s^*\right| = \left|t^*\right|$ (as in, two
sequences of letters of the same length). Let us define a function $remove$ such that \[
    remove \left(s^*\right) = s
\]
Effectively, the star indicates we are in the extended alphabet, that contains spaces. We may \textit{align} sequences
through adding spaces. These alignments need not be minimal, for example: \[
    \begin{bmatrix}
        A & A & C & T & - & - & - \\
        - & - & - & - & A & G & T \\
    \end{bmatrix}
\]
is an acceptable alignment. Not useful, perhaps, but still acceptable. Our only limitation regarding alignments is that
we may not match (defined below) 2 spaces. \\

Let us consider the following matching: 
\[
    \begin{bmatrix}
        C & - & G & A & G & T & G \\
        C & T & A & A & C & T & G
    \end{bmatrix}
\]
In the first position, we have a \enquote{match}. Second position, where there is T to $-$ we have an \enquote{indel}. In
the third position, A and G do not match, and so we have a \enquote{mismatch}.

In order to define how good a match is, we need to give scores to each of the options match, indel, and mismatch. These
are effectively learned parameters. Our question here would be \enquote{Given $s, t, \sigma$, find the alignment with
the maximum score}.

\subsection{Dynamic programming}%
\label{sub:Dynamic programming}
Since we learnt this in \textit{Algorithms}, we will go over this very quickly. The idea is that we want to split a
large problem recursively down into smaller problems, that we can then solve quickly, and use their results to solve
larger problems. \\ 
How would we solve this with dynamic programming? Let us suppose the sequences $s, t$, such that \begin{gather*}
    s = s_p T \\ 
    t = t_p T
\end{gather*}
There are 3 options we may take when making $s^*, t^*$: \begin{gather*}
    s_p^* T \\ 
    t_p^* T \\ 
    \text{====}  \\ 
    s_p^* - \\ 
    t_p^* T \\
    \text{====}  \\ 
    s_p^* T \\ 
    t_p^* -
\end{gather*}

So, we may now solve \[
    V \left(s, t\right) = \displaystyle\max_{} \begin{cases}
        V \left(s_p, t_p\right) + \sigma \left(T, T\right), &\text{ s.t. }\left|s^*\right| = \left|t^*\right| \\
        V \left(s_p, t\right) + \sigma \left(T, -\right), &\text{ } remove \left(s^*\right) = s \\
        V \left(s, t_p\right) + \sigma \left(-, T\right), &\text{ } remove \left(t^*\right) = t \\
    \end{cases}\]

From here, we may build the table, such that \begin{gather*}
    V \left[0, 0\right] = 0 \\
    V \left[1, j\right] = max score \left\{s \left[1: i\right], t \left[1: j\right]\right\} \\ 
    V \left[i, j\right] = \displaystyle\max_{} \begin{cases} 
        V \left[i - 1, j - 1\right] + \sigma \left(s_i, t_i\right) \\ 
        V \left[i - 1, j\right] + \sigma \left(s_i, -\right) \\
        V \left[i, j - 1\right] + \sigma \left(-, t_i\right)
\end{cases}
\end{gather*}
The best score will appear in the bottom right hand corner of the table. However, this is just the score, and not the
chosen matching. In order to find the chosen matching, we must work backwards through the table. We may work backwards
to any of the following three cells: above, left upper diagonal, and left. We remember the paths that lead us to each
cell, and may then chose whichever path that leads to the final cell that we like.

Given $\left|s\right| = n, \left|t\right| = m$, this will use $O \left(n \cdot m\right)$ space, and $O \left(n \cdot
m\right)$ time. This is polynomial, so in the eyes of the algorithms course, wonderful! However, it is nonlinear, so in
the eyes of DAST, not so good. Additionally, we know that $m$ and $n$ are usually very large, so this is not great... \\ 
Since space requires hardware, whereas time just requires us to wait, we will worry about space first, and then time,
since we can (probably) just wait longer.

\subsubsection{Linear space alignment}%
\label{sub:Linear space alignment}
The idea is that if we can know where the optimal alignment crosses the halfway points of the sequences, then we have
split the problem into two smaller problems. So instead of \begin{gather*}
    V \left[1, j\right] = max score \left\{s \left[1: i\right], t \left[1: j\right]\right\} \\ 
\end{gather*}
Let us define \begin{gather*}
    U \left[1, j\right] = max score \left\{s \left[i + 1: n\right], t \left[j + 1: m\right]\right\} \\ 
\end{gather*}
So, the value of \begin{gather*}
    V \left[\frac{n}{2}, j\right] + U \left[\frac{n}{2}, j\right]
\end{gather*}

From this, we will get the point that the optimal path crosses $\frac{n}{2} $. Now we have split the problem into the
two sub problems, we can now repeat recursively. \\ 
Now, how is this done in linear space? Well, we only need to save one cell in every column, so this will take $O
\left(n\right)$ space. However, since we still do this calculation for every cell in the matrix, the time will still be
$O \left(n \cdot m\right)$.

\subsection{Different alignments}%
\label{sub:Different alignments}
There are two main types of alignments. Global alignment, and local alignment. Global alignment is interested in finding
the alignment between the entire two sequences and is what we have discussed until now. Local alignment is looking if
there are local sections within the sequences that align. For local alignment, let us define $V$ as follows:
\begin{gather*}
    V_l \left[i, j\right] = \displaystyle\max_{l \leq i, k \leq j} score \left\{ s \left[l: i\right], t \left[k:
    j\right]\right\}  \\
    V_l \left[i, j\right] = max \begin{cases}
        V_l \left[i - 1, j - 1\right] + \sigma \left(s_i, t_j\right) \\
        V_l \left[i - 1, j\right] + \sigma \left(s_i, -\right) \\
        V_l \left[i, j - 1\right] + \sigma \left(-, t_j\right) \\
        0
    \end{cases}
\end{gather*}
Our matrix is now always non-negative.



\end{document}
